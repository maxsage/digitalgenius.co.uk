<!DOCTYPE HTML>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="http://www.diggen.co.uk/csharp.css" />
    <link rel="stylesheet" type="text/css" href="http://www.diggen.co.uk/master.css" />
</head>
<body>
<h1>Putting Reflection, Late Binding, and Custom Attributes in Perspective</h1>
<p> Even though you have seen numerous examples of these techniques in action, you may still be
wondering when to make use of reflection, dynamic loading, late binding, and custom attributes in your
programs? To be sure, these topics can seem a bit on the academic side of programming (which may or
may not be a bad thing, depending on your point of view). To help map these topics to a real-world
situation, you need a solid example. Assume for the moment that you are on a programming team that is
building an application with the following requirement:</p>
<ul>
 <li>
  <p>The product must be extendable by the use of additional third-party tools.</p>
 </li>
</ul>
<p>What exactly is meant by extendable? Well, consider the Visual Studio 2010 IDE. When this
application was developed, various “hooks” were inserted into the code base to allow other software
vendors to “snap” (or plug-in) custom modules into the IDE. Obviously, the Visual Studio 2010
development team had no way to set references to external .NET assemblies it had not developed yet
(thus, no early binding), so how exactly would an application provide the required hooks? Here is one
possible way to solve this problem:</p>
<ul>
 <li>First, an extendable application must provide some input vehicle to allow the user
to specify the module to plug in (such as a dialog box or command-line flag). This
requires dynamic loading.</li>
 <li>Second, an extendable application must be able to determine whether the module
supports the correct functionality (such as a set of required interfaces) in order to
be plugged into the environment. This requires reflection.</li>
 <li>Finally, an extendable application must obtain a reference to the required
infrastructure (such as a set of interface types) and invoke the members to trigger
the underlying functionality. This may require late binding.</li>
</ul>
<p>Simply put, if the extendable application has been preprogrammed to query for specific interfaces,
it is able to determine at runtime whether the type can be activated. Once this verification test has been
passed, the type in question may support additional interfaces that provide a polymorphic fabric to their
functionality. This is the exact approach taken by the Visual Studio 2010 team, and despite what you may
be thinking, is not at all difficult!</p>
    </body>
    </html>
     
      
   
