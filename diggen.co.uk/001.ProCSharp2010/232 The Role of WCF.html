<!DOCTYPE HTML>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="../csharp.css" />
    <link rel="stylesheet" type="text/css" href="../master.css" />
</head>
<body>
<h1>The Role of WCF</h1>
<p>The wide array of distributed technologies makes it difficult to pick the right tool for the job. This is
further complicated by the fact that several of these technologies overlap in the services they provide
(most notably in the areas of transactions and security).</p>
<p>Even when a .NET developer has selected what appear to be the correct technologies for the task at
hand, building, maintaining, and configuring such an application is complex, at best. Each API has its
own programming model, its own unique set of configuration tools, and so forth.</p>
<p>Prior to .NET 3.0, this meant that it was difficult to plug and play distributed APIs without authoring
a considerable amount of custom infrastructure. For example, if you build your system using the .NET
remoting APIs, and you later decide that XML web services are a more appropriate solution, you need to
reengineer your code base.</p>
<p>WCF is a distributed computing toolkit introduced with .NET 3.0 that integrates these previously
independent distributed technologies into a streamlined API represented primarily by the
System.ServiceModel namespace. Using WCF, you can expose services to callers using a wide variety of
techniques. For example, if you build an in-house application where all connected machines are
Windows based, you can use various TCP protocols to ensure the fastest-possible performance. You can
also expose this same service with the XML web service–based protocol to allow external callers to
leverage its functionality, regardless of the programming language or operating system.</p>
<p>Given the fact that WCF allows you to pick the correct protocol for the job (using a common
programming model), you will find that it becomes quite easy to plug and play the underlying plumbing
of your distributed application. In most cases, you can do so without having to recompile or redeploy the
client/service software because the grungy details are often relegated to application configuration files
(much like the older .NET remoting APIs). </p>
<h2>An Overview of WCF Features</h2>
<p>Interoperability and integration of diverse APIs are only two (important) aspects of WCF. WCF also
provides a rich software fabric that complements the remoting technologies it exposes. Consider the
following list of major WCF features:</p>
<ul>
 <li>Support for strongly typed as well as untyped messages. This approach allows
.NET applications to share custom types efficiently, while software created using
other platforms (such as Java) can consume streams of loosely typed XML.</li>
 <li>Support for several bindings (e.g., raw HTTP, TCP, MSMQ, and named pipes)
allows to choose the most appropriate plumbing to transport message data.</li>
 <li>Support for the latest and greatest web service specifications (WS-*).</li>
 <li>A fully integrated security model encompassing both native Windows/.NET
security protocols and numerous neutral-security techniques built on web service
standards.</li>
 <li>Support for session-like state management techniques, as well as support for oneway
or stateless messages. </li>
</ul>
<p>As impressive as this list of features might be, it only scratches the surface of the functionality WCF
provides. WCF also offers tracing and logging facilities, performance counters, a publish-and-subscribe
event model, and transactional support, among other features.</p>
<h2>An Overview of Service-Oriented Architecture</h2>
<p>Yet another benefit of WCF is that it is based on the design principles established by service-oriented
architecture (SOA). To be sure, SOA is a major buzzword in the industry; and like most buzzwords, SOA
can be defined in numerous ways. Simply put, SOA is a way to design a distributed system where several
autonomous services work in conjunction by passing messages across boundaries (either networked
machines or two processes on the same machine) using well-defined interfaces.</p>
<p>In the world of WCF, you typically create these well-defined interfaces using CLR interface types
(see Chapter 9). In a more general sense, however, the interface of a service simply describes the set of
members that might be invoked by external callers.</p>
<p>The team that designed WCF observed the four tenets of SOA design principles. While these tenets
are typically honored automatically simply by building a WCF application, understanding these four
cardinal design rules of SOA can help you understand WCF better. The sections that follow provide a
brief overview of each tenet.</p>
<h2>Tenet 1: Boundaries Are Explicit</h2>
<p>This tenet reiterates the fact that the functionality of a WCF service is expressed using well-defined
interfaces (e.g., descriptions of each member, its parameters, and its return values). The only way that an
external caller can communicate with a WCF service is through the interface, and the external caller
remains blissfully unaware of the underlying implementation details.</p>
<h2>Tenet 2: Services Are Autonomous</h2>
<p>The term autonomous entities refers to the fact that a given WCF service is (as much as possible) an
island unto itself. An autonomous service should be independent with regard to version, deployment,
and installation issues. To help promote this tenet, you can fall back on a key aspect of interface-based
programming. Once an interface is in production, it should never be changed (or you will risk breaking
existing clients). When you need to extend the functionality of your WCF service, you author new
interfaces that model the desired functionality.</p>
<h2>Tenet 3: Services Communicate via Contract, Not Implementation</h2>
<p>The third tenet is yet another byproduct of interface-based programming. The implementation details of
a WCF service (e.g., the language it was written in how it gets accomplishes its work, etc.) are of no
concern to the external caller. WCF clients interact with services solely through their exposed public
interfaces. Furthermore, if the members of a service interface expose custom complex types, they need
to be fully detailed as a data contract to ensure that all callers can map the content to a particular data
structure.</p>
<h2>Tenet 4: Service Compatibility Is Based on Policy</h2>
<p>Because CLR interfaces provide strongly typed contracts for all WCF clients (and can also be used to
generate a related WSDL document based on your choice of binding), it is important to realize that
interfaces and WSDL alone are not expressive enough to detail aspects of what the service is capable of
doing. Given this, SOA allows you to define policies that further qualify the semantics of the service (e.g.,
the expected security requirements used to talk to the service). Using these policies, you can basically
separate the low-level syntactic description of your service (the exposed interfaces) from the semantic
details of how they work and how they need to be invoked.</p>
<h2>WCF: The Bottom Line</h2>
<p>The preceding short history lesson explains why WCF is the preferred approach for building distributed
applications under .NET 3.0 and later. WCF is the recommended API whether you want to build an inhouse
application using TCP protocols, move data between programs on the same machine using
named pipes, or expose data to the world at large using web service protocols.</p>
<p>This is not to say that you cannot use the original .NET distributed-centric namespaces (e.g.,
System.Runtime.Remoting, System.Messaging, System.EnterpriseServices, and System.Web.Services) in
new development efforts. In some cases (e.g., if you need to build COM+ objects), you must do so. In any
case, if you have used these APIs in previous projects, you will find learning WCF straightforward. Like
the technologies that preceded it, WCF makes considerable use of XML-based configuration files, .NET
attributes, and proxy generation utilities.</p>
<p>With this introductory foundation behind you, you can concentrate on the topic of building WCF
applications. Again, you should understand that full coverage of WCF would require an entire book
because each of the supported services (e.g., MSMQ, COM+, P2P, and named pipes) could be a chapter
unto itself. Here, you will learn the overall process of building WCF programs using both TCP- and
HTTP-based (e.g., web service) protocols. This should put you in a good position to study these topics
further, as you see fit.</p>
    </body>
    </html>
 
   

