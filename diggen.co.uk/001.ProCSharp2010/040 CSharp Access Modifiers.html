<!DOCTYPE HTML>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="../csharp.css" />
    <link rel="stylesheet" type="text/css" href="../master.css" />
</head>
<body>
    <h1>C# Access Modifiers</h1>
    <p>When working with encapsulation, you must always take into account which aspects
        of a type are visible to various parts of your application. Specifically, types
        (classes, interfaces, structures, enumerations, and delegates) as well as their
        members (properties, methods, constructors, and fields) are defined using a specific
        keyword to control how "visible" the item is to other parts of your application.
        Although C# defines numerous keywords to control access, they differ on where they
        can be successfully applied (type or member). Table 5-1 documents the role of each
        access modifier and where it may be applied.</p>
    <p><b>Table 5-1.</b> C# Access Modifiers</p>
    <table class="gridtable">
        <tr>
            <th>C# Access Modifier </th>
            <th>May Be Applied To </th>
            <th>Meaning In Life </th>
        </tr>
        <tr>
            <td>public </td>
            <td>Types or type members </td>
            <td>Public items have no access restrictions. A public member can be accessed from an
                object as well as any derived class. A public type can be accessed from other external
                assemblies. </td>
        </tr>
        <tr>
            <td>private </td>
            <td>Type members or nested types </td>
            <td>Private items can only be accessed by the class (or structure) that defines the
                item. </td>
        </tr>
        <tr>
            <td>protected </td>
            <td>Type members or nested types </td>
            <td>Protected items can be used by the class which defines it, and any child class.
                However, protected items cannot be accessed from the outside world using the C#
                dot operator. </td>
        </tr>
        <tr>
            <td>internal </td>
            <td>Types or type members </td>
            <td>Internal items are accessible only within the current assembly. Therefore, if you
                define a set of internal types within a .NET class library, other assemblies are
                not able to make use of them. </td>
        </tr>
        <tr>
            <td>protected internal </td>
            <td>Type members or nested types </td>
            <td>When the protected and internal keywords are combined on an item, the item is accessible
                within the defining assembly, the defining class, and by derived classes. </td>
        </tr>
    </table>
    <p>In this chapter, you are only concerned with the public and private keywords. Later chapters will
        examine the role of the internal and protected internal modifiers (useful when you build .NET code
        libraries) and the protected modifier (useful when you are creating class hierarchies).</p>
    <h2>The Default Access Modifiers</h2>
    <p>By default, type members are implicitly private while types are implicitly internal.
        Thus, the following class definition is automatically set to internal, while the
        type's default constructor is automatically set to private:</p>
<!-- code formatted by http://manoli.net/csharpformat/ -->
<pre class="csharpcode">
<span class="rem">// An internal class with a private default constructor.</span>
<span class="kwrd">class</span> Radio
{
    Radio(){}
}</pre>
    <p>To allow other parts of a program to invoke members of an object, you must mark them
        as publicly accessible. As well, if you wish to expose the Radio to external assemblies
        (useful when building .NET code libraries) you will need to add the public modifier.</p>
<!-- code formatted by http://manoli.net/csharpformat/ -->
<pre class="csharpcode">
<span class="rem">// A public class with a public default constructor.</span>
<span class="kwrd">public</span> <span class="kwrd">class</span> Radio
{
    <span class="kwrd">public</span> Radio(){}
}</pre>
    <h2>Access Modifiers and Nested Types</h2>
    <p>As mentioned in Table 5-1, the private, protected, and protected internal access modifiers can be applied to
        a nested type. What you need to know at this point, however, is that a nested type
        is a type declared directly within the scope of class or structure. By way of example,
        here is a private enumeration (named Color) nested within a public class (named
        SportsCar):</p>
<!-- code formatted by http://manoli.net/csharpformat/ -->
<pre class="csharpcode">
<span class="kwrd">public</span> <span class="kwrd">class</span> SportsCar
{
    <span class="rem">// OK! Nested types can be marked private.</span>
    <span class="kwrd">private</span> <span class="kwrd">enum</span> CarColor
    {
        Red, Green, Blue
    }
}</pre>
    <p>Here, it is permissible to apply the private access modifier on the nested type.
        However, nonnested types (such as the SportsCar) can only be defined with the public
        or internal modifiers. Therefore, the following class definition is illegal:</p>
<!-- code formatted by http://manoli.net/csharpformat/ -->
<pre class="csharpcode">
<span class="rem">// Error! Nonnested types cannot be marked private!</span>
<span class="kwrd">private</span> <span class="kwrd">class</span> SportsCar
{}</pre>
    <p>Now that you have seen the access modifiers at work, you are ready to formally investigate the first
        pillar of OOP.</p>
</body>
</html>
